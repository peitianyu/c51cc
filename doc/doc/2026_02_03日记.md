wsl -d test bash -lc "set -e; cd /mnt/d/ws/test/C51CC; printf '4\ntest/hex_verify.c\n' | ./build.sh" 检查一下ssa输出存在问题, 更新如下:
1. 问题
	- SSA 优化里对 IROP_STORE 做常量标记时清空了 args，导致后续 store->load 转发无法识别同一地址的最新写入，普通全局变量场景会错过常量分支折叠。
	- 常量分支消除只把 br 替换成 jmp，但未做可达性分析，死块仍会被打印出来。
	- 该测试用例是 register(P1) 类型，编译器将其视为 MMIO/volatile，按语义不应把 store->load 折叠成常量分支，SSA 输出保留 br 是预期现象。
2. 如何解决
	- 保留 IROP_STORE 的 args，仅追加 @label/imm 标记，保证 store->load 转发可用；并在常量分支消除后做可达性分析，清空不可达块避免输出死块。
	- 为了让当前示例也折叠：store->load 转发仅屏蔽 volatile，不屏蔽 register；补了比较自反/常量比较折叠；并修复了分支折叠时标签被提前释放导致跳转错误的问题。

3. 目前优化结果（摘要）
	- 分支已折叠为单路径，死块被清空；仅保留必要块。
	- 多余 `addr` 与冗余 `const` 定义已隐藏/清理，`ret` 支持直接打印常量。
	- 基本块合并与尾部 `ret` 合并已生效，控制流进一步压缩为单块。
	- 当前样例最终 SSA：
	  .b0:
	    store @P1, const 0
	    store @P1, const 15
	    ret const 0

