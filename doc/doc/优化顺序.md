A. 在 SSA「构造」阶段就能顺手做的局部/半局部优化；
B. 构造完一次后，在「Raw-SSA → 最终 SSA」之间跑一趟轻量级 Pass。

A. 构造期“顺手”优化（零额外开销）
1. 常量折叠（Constant Folding）
    场景：_convert_node 里遇到 BinaryOp，左右都是 ConstantValue。
    做法：直接算出结果，返回 create_constant(结果)，一条指令都不生成。
    效果：把 x = 5 + 3 直接变成 x = 8，AST→SSA 阶段就消失。
2. 复制传播（Copy Propagation）＝ 平凡 φ 删除的延伸
    你已经实现了“所有前驱值相同”就替换；
    可以再加一条：如果某 φ 的两个来源分别是 v7、v7，也立即合并。
    更狠一点：对普通指令 v9 = add v7, 0 也当场替换成 v7，省去后面再跑 Pass。
3. 死代码消除（DCE）「半局部版」
    场景：指令生成后立刻发现无用户。
    做法：在 create_instruction 末尾加
    if not ops: inst.remove_from_block(); return ops[0] if len(ops)==1 else inst
    这样 x = (y+0) 在折叠成 x = y 后，那条 add 指令会被当场删掉。
4. 控制流简化
    4a. 空分支合并
        如果 then/else 都只有一条 jmp merge，且没有产生新变量版本，
        可把 br 换成 jmp，并删掉空分支块。
    4b. 跳转线程（Jump Threading）
        当前块末尾是 jmp B，而 B 的唯一指令又是 jmp C，
        直接把 jmp 目标改成 C，省一次跳转。
        这两种在 _convert_if / _convert_while 末尾顺手做，只需要检查块内指令数量和后继 preds 数目。
B. 构造完跑一趟“微型 Pass”
5. 再跑一次全局平凡 φ 删除
    构造期只能做“局部看到的”平凡 φ；
    构造完后，可能出现“v10 = φ(v9), v9 = φ(v8), v8 = φ(v7)” 这种链。
    一趟 RPO 遍历，把 φ 链一直追到非 φ 为止，能再删 5~15%。
6. 死代码消除（真·全局）
    从“返回值 + 副作用指令”出发做一次 mark-sweep：
    – 把 print/store/return/branch 标为“有用”；
    – 其他指令只有被有用指令“真用到”才标有用；
    – 清扫阶段把未标记指令从 block.instructions 里 pop 掉。
7. 常量传播（Constant Propagation）
    一趟 RPO + 工作列表：
    – 遇到 v = const 把 v 标为常数；
    – 遇到 v = add c1, c2 把 v 标为常数；
    – 遇到 φ 只要所有前驱都是同一常数，也把 v 标为常数；
    – 替换所有使用处，再触发一次折叠。
8. 块合并（Block Merging）
    如果 A 的唯一后继是 B，且 B 的唯一前驱是 A，
    把 B 的指令搬到 A 末尾，更新跳转，删掉 B。
    能把“then → merge”这种典型模式压平，减少 10~20% 块数量。

落地顺序建议
step-0  原始框架
step-1  顺手做 1.常量折叠 2.复制传播 3.半局部DCE（+A 全部）
step-2  构造完跑一次 5.全局平凡φ + 6.全局DCE
step-3  加 7.常量传播，再跑一次 6.DCE 收尾
step-4  最后 8.块合并，把控制流压扁